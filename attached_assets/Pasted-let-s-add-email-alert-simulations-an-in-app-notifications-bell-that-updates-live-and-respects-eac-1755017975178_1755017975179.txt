let’s add email alert simulations + an in-app notifications bell that updates live (and respects each user’s preferences). Everything below is paste-ready.

1) Backend — notification store + router + event listener
1a) Create lib/notifications.js
js
Copy code
// lib/notifications.js
// Persisted notifications per user (in data/notifications.json)
// Shape: [{ id, to, type, title, body, ref, ts, read: false }]

import { readJson, writeJson } from "./store.js";

const FILE = "notifications.json";

function load() {
  try {
    const arr = readJson(FILE);
    return Array.isArray(arr) ? arr : [];
  } catch {
    writeJson(FILE, []);
    return [];
  }
}
function save(list) { writeJson(FILE, list); }

function nextId(list) {
  const n = (list[0]?.idNum || 1000) + 1;
  return { id: `N-${n}`, idNum: n };
}

export function addNotification({ to, type, title, body, ref }) {
  const list = load();
  const { id, idNum } = nextId(list);
  const rec = {
    id, idNum,
    to: String(to).toLowerCase(),
    type, title: String(title || "").slice(0, 160),
    body: String(body || "").slice(0, 2000),
    ref: ref || null,
    ts: new Date().toISOString(),
    read: false
  };
  list.unshift(rec);
  save(list);
  return rec;
}

export function listForUser(email, { limit = 50 } = {}) {
  const e = String(email || "").toLowerCase();
  return load().filter(n => n.to === e).slice(0, limit);
}

export function markRead(email, id) {
  const e = String(email || "").toLowerCase();
  const list = load();
  const idx = list.findIndex(n => n.to === e && n.id === id);
  if (idx === -1) return false;
  list[idx].read = true;
  save(list);
  return true;
}

export function markAllRead(email) {
  const e = String(email || "").toLowerCase();
  const list = load();
  let changed = 0;
  for (const n of list) {
    if (n.to === e && !n.read) { n.read = true; changed++; }
  }
  save(list);
  return changed;
}

export function unreadCount(email) {
  const e = String(email || "").toLowerCase();
  return load().filter(n => n.to === e && !n.read).length;
}
1b) Create lib/notifier.js (subscribe to events, respect preferences)
js
Copy code
// lib/notifier.js
// Listens to dashboard events and writes notifications for users who opted in.

import { bus } from "./events.js";
import { readJson } from "./store.js";
import { addNotification } from "./notifications.js";

function getUsers() {
  try {
    const u = readJson("users.json");
    return Array.isArray(u) ? u : [];
  } catch { return []; }
}

function shouldNotify(user, key) {
  // key in ["approvals","breaches","rfpStages"]
  const prefs = user?.preferences || {};
  const e = prefs.emailAlerts || {};
  return Boolean(e[key]);
}

// Map events -> notification template
function handleEvent(evt) {
  const { type, payload = {} } = evt || {};
  const users = getUsers();

  if (type === "rfp.stage") {
    for (const u of users) {
      if (!shouldNotify(u, "rfpStages")) continue;
      addNotification({
        to: u.email,
        type: "RFP",
        title: `RFP stage → ${payload.stage}`,
        body: `RFP ${payload.id} moved to ${payload.stage}.`,
        ref: payload.id
      });
    }
  }

  if (type === "breach.update" || type === "breach.create") {
    for (const u of users) {
      if (!shouldNotify(u, "breaches")) continue;
      const title = type === "breach.create" ? "New Mandate Breach" : "Breach Updated";
      addNotification({
        to: u.email,
        type: "Breach",
        title,
        body: `Mandate ${payload.mandateId} – ${payload.breachId} ${payload.status ? "→ "+payload.status : ""}`,
        ref: payload.mandateId
      });
    }
  }

  // (Optional) approvals events—wire these once you emit them from approvals routes:
  if (type === "approval.created" || type === "approval.assigned") {
    for (const u of users) {
      if (!shouldNotify(u, "approvals")) continue;
      addNotification({
        to: u.email,
        type: "Approval",
        title: type === "approval.created" ? "New Approval" : "Approval Assigned",
        body: `Approval ${payload.id || ""} ${payload.summary || ""}`,
        ref: payload.id
      });
    }
  }
}

export function initNotifier() {
  bus.on("dashboard:event", handleEvent);
}
1c) Create routes/notifications.js
js
Copy code
// routes/notifications.js
import { Router } from "express";
import { requireAuth } from "../lib/auth.js";
import { listForUser, markRead, markAllRead, unreadCount } from "../lib/notifications.js";

const router = Router();

// List + unread count
router.get("/", requireAuth, (req, res) => {
  const me = req.user?.sub;
  const list = listForUser(me, { limit: 100 });
  const unread = unreadCount(me);
  res.json({ notifications: list, unread });
});

// Mark one as read
router.post("/:id/read", requireAuth, (req, res) => {
  const ok = markRead(req.user?.sub, req.params.id);
  if (!ok) return res.status(404).json({ error: "Not found" });
  res.json({ ok: true });
});

// Mark all as read
router.post("/read-all", requireAuth, (req, res) => {
  const changed = markAllRead(req.user?.sub);
  res.json({ ok: true, changed });
});

export default router;
1d) Wire into server.js
Add imports:

js
Copy code
import notificationsRoutes from "./routes/notifications.js";
import { initNotifier } from "./lib/notifier.js";
Mount API:

js
Copy code
app.use("/api/notifications", notificationsRoutes);
Init the notifier after app routes are set up (so the bus exists everywhere):

js
Copy code
initNotifier();
You already emit dashboard events (Step 3). These will now generate per-user notifications based on their Profile → Preferences → Email Alerts toggles.

2) Frontend — bell widget + live updates + nav actions
2a) API helpers in public/app.js (near other helpers)
js
Copy code
// === Notifications API ===
async function notifList(){ return await apiGet("/notifications"); }
async function notifRead(id){
  return await apiFetch(`/notifications/${encodeURIComponent(id)}/read`, { method: "POST" });
}
async function notifReadAll(){
  return await apiFetch("/notifications/read-all", { method: "POST" });
}
2b) Add a bell to your top bar
Find your topNav() function. After you create the right-hand controls (or add one if not present), append this bell UI:

js
Copy code
function topNav(){
  const nav = document.createElement("div");
  nav.className = "topnav";

  // Brand (already clickable back to Dashboard per earlier change)
  const brand = document.createElement("div");
  brand.className = "brand";
  brand.textContent = "J.P.Morgan — AM Workspace";
  brand.style.cursor = "pointer";
  brand.onclick = () => { state.view = "dashboard"; render(); };
  nav.appendChild(brand);

  // Right side
  const right = document.createElement("div");
  right.className = "topnav-right";
  nav.appendChild(right);

  // Notifications bell
  const bellWrap = document.createElement("div");
  bellWrap.className = "notif-wrap";
  bellWrap.innerHTML = `
    <button class="icon-btn" id="btnBell" aria-label="Notifications">
      <span class="bell">🔔</span>
      <span class="badge" id="notifCount" style="display:none;">0</span>
    </button>
    <div class="notif-panel card" id="notifPanel" style="display:none;">
      <div class="p">
        <div class="flex-between">
          <b>Notifications</b>
          <button class="btn-ghost" id="markAll">Mark all read</button>
        </div>
        <div id="notifList" class="notif-list"></div>
      </div>
    </div>
  `;
  right.appendChild(bellWrap);

  // Profile shortcut
  const prof = document.createElement("button");
  prof.className = "btn-ghost";
  prof.textContent = "Profile";
  prof.onclick = () => { state.view = "profile"; render(); };
  right.appendChild(prof);

  // Wire bell
  (async function initBell(){
    await refreshBell();
    // live via SSE (if enabled in profile; DashboardMain also sets up SSE – this is independent & lightweight)
    try {
      const es = new EventSource("/api/dashboard/stream");
      es.addEventListener("dash", async () => { await refreshBell(); });
      es.addEventListener("ping", () => {});
      es.onerror = () => { es.close?.(); };
    } catch {}
  })();

  async function refreshBell(){
    try {
      const { notifications = [], unread = 0 } = await notifList();
      const badge = bellWrap.querySelector("#notifCount");
      badge.textContent = String(unread);
      badge.style.display = unread > 0 ? "" : "none";

      const list = bellWrap.querySelector("#notifList");
      list.innerHTML = notifications.slice(0, 20).map(n => `
        <div class="notif-row ${n.read ? "read" : "unread"}" data-id="${n.id}" data-ref="${n.ref || ""}" data-type="${n.type}">
          <div class="notif-title">
            <b>${n.title}</b> <span class="muted small">• ${new Date(n.ts).toLocaleString()}</span>
          </div>
          <div class="muted">${n.body || ""}</div>
        </div>
      `).join("") || `<div class="muted">No notifications.</div>`;
    } catch (e) {
      // ignore
    }
  }

  // Toggle panel
  const btn = bellWrap.querySelector("#btnBell");
  const panel = bellWrap.querySelector("#notifPanel");
  btn.onclick = () => {
    panel.style.display = panel.style.display === "none" ? "" : "none";
  };
  document.addEventListener("click", (e) => {
    if (!bellWrap.contains(e.target)) panel.style.display = "none";
  });

  // Click notifications to deep-link
  bellWrap.querySelector("#notifList").addEventListener("click", async (e) => {
    const row = e.target.closest(".notif-row");
    if (!row) return;
    const id = row.dataset.id;
    const ref = row.dataset.ref || "";
    const type = (row.dataset.type || "").toLowerCase();
    try { await notifRead(id); } catch {}

    // Navigate by type/ref
    if (type === "rfp") {
      state.view = "rfp";
      state.rfpId = ref || state.rfpId;
    } else if (type === "breach") {
      state.view = "mandate";
      state.mandateId = ref || state.mandateId;
    } else if (type === "approval") {
      state.view = "approvals";
    } else {
      state.view = "dashboard";
    }
    render();
  });

  // Mark all read
  bellWrap.querySelector("#markAll").onclick = async () => {
    try { await notifReadAll(); await refreshBell(); } catch {}
  };

  return nav;
}
2c) Minimal CSS (append to public/style.css)
css
Copy code
/* Notifications bell */
.topnav { display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; border-bottom:1px solid var(--line); background:#fff; position: sticky; top:0; z-index: 20; }
.topnav-right { display:flex; align-items:center; gap:8px; }
.icon-btn { border:0; background:transparent; cursor:pointer; position:relative; }
.notif-wrap { position: relative; }
.badge { position:absolute; top:-4px; right:-6px; background:#ef4444; color:#fff; border-radius:999px; padding:0 6px; font-size:11px; line-height:16px; min-width: 18px; text-align:center; }
.notif-panel { position:absolute; right:0; top:36px; width: 360px; max-height: 420px; overflow:auto; border:1px solid var(--line); border-radius:12px; background:#fff; box-shadow: 0 6px 20px rgba(0,0,0,.08); }
.notif-list { display:flex; flex-direction:column; gap:10px; margin-top:8px; }
.notif-row { padding:8px; border:1px solid var(--line); border-radius:10px; cursor:pointer; }
.notif-row:hover { background:#f9fafb; }
.notif-row.unread { border-color:#c7d2fe; box-shadow: inset 0 0 0 1px #c7d2fe; }
.notif-title { display:flex; gap:8px; align-items:baseline; }
3) Hook events you already emit (done in Step 3)
You already emit events from:

routes/rfps.js (rfp.create / .update / .stage / .note / .checklist / .attachment)

routes/mandates.js (mandate.create / .update / .delete / breach.create / breach.update)

The notifier listens to these and drops notifications for users who opted in under Profile → Notifications & Preferences:

RFP stage → preference emailAlerts.rfpStages

Breaches create/update → emailAlerts.breaches

(Optional) If/when you emit approval.* events, they’ll respect emailAlerts.approvals

4) Respect “Live updates” preference
You already guard Dashboard SSE by reading the user’s preferences.liveUpdates. The bell also connects to the same SSE stream and calls notifList() on events. If you want to strictly respect the preference for the bell too, wrap the EventSource in a fetchMe() check and only connect if liveUpdates !== false.

Example tweak in topNav():

js
Copy code
(async () => {
  await refreshBell();
  const me = await fetchMe();
  if (me?.preferences?.liveUpdates !== false) {
    const es = new EventSource("/api/dashboard/stream");
    es.addEventListener("dash", async () => { await refreshBell(); });
    es.addEventListener("ping", () => {});
    es.onerror = () => { es.close?.(); };
  }
})();