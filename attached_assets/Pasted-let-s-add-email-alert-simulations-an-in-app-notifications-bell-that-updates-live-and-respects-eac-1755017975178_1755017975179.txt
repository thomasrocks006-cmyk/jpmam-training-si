letâ€™s add email alert simulations + an in-app notifications bell that updates live (and respects each userâ€™s preferences). Everything below is paste-ready.

1) Backend â€” notification store + router + event listener
1a) Create lib/notifications.js
js
Copy code
// lib/notifications.js
// Persisted notifications per user (in data/notifications.json)
// Shape: [{ id, to, type, title, body, ref, ts, read: false }]

import { readJson, writeJson } from "./store.js";

const FILE = "notifications.json";

function load() {
  try {
    const arr = readJson(FILE);
    return Array.isArray(arr) ? arr : [];
  } catch {
    writeJson(FILE, []);
    return [];
  }
}
function save(list) { writeJson(FILE, list); }

function nextId(list) {
  const n = (list[0]?.idNum || 1000) + 1;
  return { id: `N-${n}`, idNum: n };
}

export function addNotification({ to, type, title, body, ref }) {
  const list = load();
  const { id, idNum } = nextId(list);
  const rec = {
    id, idNum,
    to: String(to).toLowerCase(),
    type, title: String(title || "").slice(0, 160),
    body: String(body || "").slice(0, 2000),
    ref: ref || null,
    ts: new Date().toISOString(),
    read: false
  };
  list.unshift(rec);
  save(list);
  return rec;
}

export function listForUser(email, { limit = 50 } = {}) {
  const e = String(email || "").toLowerCase();
  return load().filter(n => n.to === e).slice(0, limit);
}

export function markRead(email, id) {
  const e = String(email || "").toLowerCase();
  const list = load();
  const idx = list.findIndex(n => n.to === e && n.id === id);
  if (idx === -1) return false;
  list[idx].read = true;
  save(list);
  return true;
}

export function markAllRead(email) {
  const e = String(email || "").toLowerCase();
  const list = load();
  let changed = 0;
  for (const n of list) {
    if (n.to === e && !n.read) { n.read = true; changed++; }
  }
  save(list);
  return changed;
}

export function unreadCount(email) {
  const e = String(email || "").toLowerCase();
  return load().filter(n => n.to === e && !n.read).length;
}
1b) Create lib/notifier.js (subscribe to events, respect preferences)
js
Copy code
// lib/notifier.js
// Listens to dashboard events and writes notifications for users who opted in.

import { bus } from "./events.js";
import { readJson } from "./store.js";
import { addNotification } from "./notifications.js";

function getUsers() {
  try {
    const u = readJson("users.json");
    return Array.isArray(u) ? u : [];
  } catch { return []; }
}

function shouldNotify(user, key) {
  // key in ["approvals","breaches","rfpStages"]
  const prefs = user?.preferences || {};
  const e = prefs.emailAlerts || {};
  return Boolean(e[key]);
}

// Map events -> notification template
function handleEvent(evt) {
  const { type, payload = {} } = evt || {};
  const users = getUsers();

  if (type === "rfp.stage") {
    for (const u of users) {
      if (!shouldNotify(u, "rfpStages")) continue;
      addNotification({
        to: u.email,
        type: "RFP",
        title: `RFP stage â†’ ${payload.stage}`,
        body: `RFP ${payload.id} moved to ${payload.stage}.`,
        ref: payload.id
      });
    }
  }

  if (type === "breach.update" || type === "breach.create") {
    for (const u of users) {
      if (!shouldNotify(u, "breaches")) continue;
      const title = type === "breach.create" ? "New Mandate Breach" : "Breach Updated";
      addNotification({
        to: u.email,
        type: "Breach",
        title,
        body: `Mandate ${payload.mandateId} â€“ ${payload.breachId} ${payload.status ? "â†’ "+payload.status : ""}`,
        ref: payload.mandateId
      });
    }
  }

  // (Optional) approvals eventsâ€”wire these once you emit them from approvals routes:
  if (type === "approval.created" || type === "approval.assigned") {
    for (const u of users) {
      if (!shouldNotify(u, "approvals")) continue;
      addNotification({
        to: u.email,
        type: "Approval",
        title: type === "approval.created" ? "New Approval" : "Approval Assigned",
        body: `Approval ${payload.id || ""} ${payload.summary || ""}`,
        ref: payload.id
      });
    }
  }
}

export function initNotifier() {
  bus.on("dashboard:event", handleEvent);
}
1c) Create routes/notifications.js
js
Copy code
// routes/notifications.js
import { Router } from "express";
import { requireAuth } from "../lib/auth.js";
import { listForUser, markRead, markAllRead, unreadCount } from "../lib/notifications.js";

const router = Router();

// List + unread count
router.get("/", requireAuth, (req, res) => {
  const me = req.user?.sub;
  const list = listForUser(me, { limit: 100 });
  const unread = unreadCount(me);
  res.json({ notifications: list, unread });
});

// Mark one as read
router.post("/:id/read", requireAuth, (req, res) => {
  const ok = markRead(req.user?.sub, req.params.id);
  if (!ok) return res.status(404).json({ error: "Not found" });
  res.json({ ok: true });
});

// Mark all as read
router.post("/read-all", requireAuth, (req, res) => {
  const changed = markAllRead(req.user?.sub);
  res.json({ ok: true, changed });
});

export default router;
1d) Wire into server.js
Add imports:

js
Copy code
import notificationsRoutes from "./routes/notifications.js";
import { initNotifier } from "./lib/notifier.js";
Mount API:

js
Copy code
app.use("/api/notifications", notificationsRoutes);
Init the notifier after app routes are set up (so the bus exists everywhere):

js
Copy code
initNotifier();
You already emit dashboard events (Step 3). These will now generate per-user notifications based on their Profile â†’ Preferences â†’ Email Alerts toggles.

2) Frontend â€” bell widget + live updates + nav actions
2a) API helpers in public/app.js (near other helpers)
js
Copy code
// === Notifications API ===
async function notifList(){ return await apiGet("/notifications"); }
async function notifRead(id){
  return await apiFetch(`/notifications/${encodeURIComponent(id)}/read`, { method: "POST" });
}
async function notifReadAll(){
  return await apiFetch("/notifications/read-all", { method: "POST" });
}
2b) Add a bell to your top bar
Find your topNav() function. After you create the right-hand controls (or add one if not present), append this bell UI:

js
Copy code
function topNav(){
  const nav = document.createElement("div");
  nav.className = "topnav";

  // Brand (already clickable back to Dashboard per earlier change)
  const brand = document.createElement("div");
  brand.className = "brand";
  brand.textContent = "J.P.Morgan â€” AM Workspace";
  brand.style.cursor = "pointer";
  brand.onclick = () => { state.view = "dashboard"; render(); };
  nav.appendChild(brand);

  // Right side
  const right = document.createElement("div");
  right.className = "topnav-right";
  nav.appendChild(right);

  // Notifications bell
  const bellWrap = document.createElement("div");
  bellWrap.className = "notif-wrap";
  bellWrap.innerHTML = `
    <button class="icon-btn" id="btnBell" aria-label="Notifications">
      <span class="bell">ðŸ””</span>
      <span class="badge" id="notifCount" style="display:none;">0</span>
    </button>
    <div class="notif-panel card" id="notifPanel" style="display:none;">
      <div class="p">
        <div class="flex-between">
          <b>Notifications</b>
          <button class="btn-ghost" id="markAll">Mark all read</button>
        </div>
        <div id="notifList" class="notif-list"></div>
      </div>
    </div>
  `;
  right.appendChild(bellWrap);

  // Profile shortcut
  const prof = document.createElement("button");
  prof.className = "btn-ghost";
  prof.textContent = "Profile";
  prof.onclick = () => { state.view = "profile"; render(); };
  right.appendChild(prof);

  // Wire bell
  (async function initBell(){
    await refreshBell();
    // live via SSE (if enabled in profile; DashboardMain also sets up SSE â€“ this is independent & lightweight)
    try {
      const es = new EventSource("/api/dashboard/stream");
      es.addEventListener("dash", async () => { await refreshBell(); });
      es.addEventListener("ping", () => {});
      es.onerror = () => { es.close?.(); };
    } catch {}
  })();

  async function refreshBell(){
    try {
      const { notifications = [], unread = 0 } = await notifList();
      const badge = bellWrap.querySelector("#notifCount");
      badge.textContent = String(unread);
      badge.style.display = unread > 0 ? "" : "none";

      const list = bellWrap.querySelector("#notifList");
      list.innerHTML = notifications.slice(0, 20).map(n => `
        <div class="notif-row ${n.read ? "read" : "unread"}" data-id="${n.id}" data-ref="${n.ref || ""}" data-type="${n.type}">
          <div class="notif-title">
            <b>${n.title}</b> <span class="muted small">â€¢ ${new Date(n.ts).toLocaleString()}</span>
          </div>
          <div class="muted">${n.body || ""}</div>
        </div>
      `).join("") || `<div class="muted">No notifications.</div>`;
    } catch (e) {
      // ignore
    }
  }

  // Toggle panel
  const btn = bellWrap.querySelector("#btnBell");
  const panel = bellWrap.querySelector("#notifPanel");
  btn.onclick = () => {
    panel.style.display = panel.style.display === "none" ? "" : "none";
  };
  document.addEventListener("click", (e) => {
    if (!bellWrap.contains(e.target)) panel.style.display = "none";
  });

  // Click notifications to deep-link
  bellWrap.querySelector("#notifList").addEventListener("click", async (e) => {
    const row = e.target.closest(".notif-row");
    if (!row) return;
    const id = row.dataset.id;
    const ref = row.dataset.ref || "";
    const type = (row.dataset.type || "").toLowerCase();
    try { await notifRead(id); } catch {}

    // Navigate by type/ref
    if (type === "rfp") {
      state.view = "rfp";
      state.rfpId = ref || state.rfpId;
    } else if (type === "breach") {
      state.view = "mandate";
      state.mandateId = ref || state.mandateId;
    } else if (type === "approval") {
      state.view = "approvals";
    } else {
      state.view = "dashboard";
    }
    render();
  });

  // Mark all read
  bellWrap.querySelector("#markAll").onclick = async () => {
    try { await notifReadAll(); await refreshBell(); } catch {}
  };

  return nav;
}
2c) Minimal CSS (append to public/style.css)
css
Copy code
/* Notifications bell */
.topnav { display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; border-bottom:1px solid var(--line); background:#fff; position: sticky; top:0; z-index: 20; }
.topnav-right { display:flex; align-items:center; gap:8px; }
.icon-btn { border:0; background:transparent; cursor:pointer; position:relative; }
.notif-wrap { position: relative; }
.badge { position:absolute; top:-4px; right:-6px; background:#ef4444; color:#fff; border-radius:999px; padding:0 6px; font-size:11px; line-height:16px; min-width: 18px; text-align:center; }
.notif-panel { position:absolute; right:0; top:36px; width: 360px; max-height: 420px; overflow:auto; border:1px solid var(--line); border-radius:12px; background:#fff; box-shadow: 0 6px 20px rgba(0,0,0,.08); }
.notif-list { display:flex; flex-direction:column; gap:10px; margin-top:8px; }
.notif-row { padding:8px; border:1px solid var(--line); border-radius:10px; cursor:pointer; }
.notif-row:hover { background:#f9fafb; }
.notif-row.unread { border-color:#c7d2fe; box-shadow: inset 0 0 0 1px #c7d2fe; }
.notif-title { display:flex; gap:8px; align-items:baseline; }
3) Hook events you already emit (done in Step 3)
You already emit events from:

routes/rfps.js (rfp.create / .update / .stage / .note / .checklist / .attachment)

routes/mandates.js (mandate.create / .update / .delete / breach.create / breach.update)

The notifier listens to these and drops notifications for users who opted in under Profile â†’ Notifications & Preferences:

RFP stage â†’ preference emailAlerts.rfpStages

Breaches create/update â†’ emailAlerts.breaches

(Optional) If/when you emit approval.* events, theyâ€™ll respect emailAlerts.approvals

4) Respect â€œLive updatesâ€ preference
You already guard Dashboard SSE by reading the userâ€™s preferences.liveUpdates. The bell also connects to the same SSE stream and calls notifList() on events. If you want to strictly respect the preference for the bell too, wrap the EventSource in a fetchMe() check and only connect if liveUpdates !== false.

Example tweak in topNav():

js
Copy code
(async () => {
  await refreshBell();
  const me = await fetchMe();
  if (me?.preferences?.liveUpdates !== false) {
    const es = new EventSource("/api/dashboard/stream");
    es.addEventListener("dash", async () => { await refreshBell(); });
    es.addEventListener("ping", () => {});
    es.onerror = () => { es.close?.(); };
  }
})();